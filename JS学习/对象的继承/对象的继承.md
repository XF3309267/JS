# `JS` 对象的继承

### 1.  原型链

- #### 原型

  1. 每一个构造函数都有原型对象（`prototype` ),每一个原型对象上都有一个指向 构造函数的指针 （  `constructor`  ) ,  所创建的实例**一般都也有** 指向 原型对象的指针。
  2. **特殊情况：** null  是没有 原型对象的； 所以 若一个构造函数 所创建的实例是   **null** ,那实例对象就不会拥有 一个指向 原型的指针，进而也没有指向 构造函数的指针。

- **原型链**

  - 当一个实例对象  赋值给 一个构造函数原型时，构造函数的原型的属性和方法  就被  实例对象上的 属性和方法所替代，因为**实例对象都有一个 指向  构造函数原型的指针**，所以 被赋值的那个  构造函数上就有一个 类似的指针（ **指向 实例对象的 构造函数原型的指针** ）。被指向的原型  也有可能是被 其他实例对象所赋值的，所以 如此 层层递进，就构成了 实例 与 原型的链条，简称： **原型链**

#### **原型链的弊端：**

1. 构造函数 的原型对象 的引用类型属性  是会被所有实例所共享的。所以，在把实例 赋值给 原型时，难免会把 引用类型 赋值过去（ 不管这 引用类型的值 ，是对象的 静态属性，还是从 其原型中获得 ），这样就导致  所有实例 共享属性。

### 2. 对象继承

[^脚注]: （下面例子中, A  B 都为构造函数,a  b  都为相应的实例对象）

#### 1.  原型链继承

- `A.prototype = new  B()`
- 将 B 的实例 赋值给   A  的原型

- **上述已经讲过，原型链的弊端，会造成   继承者  的所有实例对象  共享某些属性**

##### 弊端： 

- 不能对继承过来的属性进行赋值，只能使用 被继承者原生默认的属性值。
- 这里说的不能，是因为  继承过来的属性  是 构造函数原型的 属性，是 会被所有实例共享，你更改了，所有实例的属性值 也就 跟着更改了。

#### 2. 借用构造函数继承

- ```js
  funciton B (){
      this.colors = ['red','blue']
  }
  funciton A(){
      B.call(this)
      this.a = 'aaa'
  }
  ```

- ` B.call(this)`  在自身的构造函数中，首先  调用一遍要继承的构造函数，以来实现   继承 B 的所有 属性和方法，这样就实现了  继承。

##### 优点：

- 可以向 父类的构造函数传递参数，实现 对属性值  赋值

##### 弊端：

- **没有实现函数复用**。即，每一次创建对象 都会重新的 赋值一遍属性值，方法也都会赋值一遍。这样仅仅是在 A  的构造函数 中，复制了一遍  B  构造函数的属性。
- A 没有获得  B 构造函数的原型，**没有实现 原型的链  的衔接。** 

#### 3. 组合式继承

- 为了让  A  继承  B。为了让  **A  得到  B 的所有属性和方法**，且  **A  接上  B  的原型链**

  1.  **B 的实例 赋值给 A 的原型**，使   A  的原型   获得  b 所有拥有的所有属性和方法，包括  b  指向 其原型 B的指针。（**因为是 实例   赋值给  原型，必然会有 原型链该有  弊端，属性共享**）

     - **B 的实例属性和方法  来自于   构造函数 B  和  B 的原型**（实例 B 没有静态属性的情况下）

  2. 为了解决**属性共享**的问题，再 在 A 的构造函数中使用   **借用构造函数**   的方法，将 B 构造函数中的属性 复制到  A 中，**实现属性的覆盖**（因为在此操作之前  A 的原型上已经有一套  构造函数 B 的属性 ）。

  3. ```js
     function A(){
         B.call(this)
         this.a = 'aaa'
     }
     A.prototype =  new B()
     //  不要忘了更改 构造函数的  constructor 属性
     // constructor 属性 存在于原型上，指向其 构造函数
     A.prototype.constructor = A
     ```

##### 优点： 

- 继承者的原型对象 上 拥有了  被继承者 原型对象的属性和方法
- 继承者 构造函数中    拥有了  被继承者 构造函数中的属性和方法

##### 弊端：

- B  构造函数调用了两次
- 实际上  继承者的原型对象上 仍然有一份  构造函数 B 所有的属性和方法，只是被   继承者构造函数的 `B.call(this)`  所覆盖了。所以，当你删除了  a 的某个属性，他仍然存在。

#### 4. 原型式继承

- ```js
  function object(super){
      function Sub(){
          
      }
      Sub.prototype = super
      return new Sub()
  }
  //  封装一个函数
  //  函数 接收  被继承者构造函数
  //  	函数内部，将 被继承者构造函数实例 赋值给 一个空白的构造函数
  //  返回 新构造函数实例
  ```

- **让一个 对象  当作  新构造函数的 原型（和 原型链  原理一致 ） **

##### `Object.create()`  

- `Object.create()`   和 上述代码块中的  `object()` 方法差不多， 实例  赋值给原型 ，返回 新构造函数实例
- `Object.create()`   接收两个参数
  1. 第一个参数是一个对象， 使用该对象  作为  构造函数的原型
  2. 第二个参数是一个对象，  使用该对象  作为  构造函数的属性值
- **弊端：对象  作为 原型，避免不了  实例的属性共享**

##### 优点：

- 继承者  继承属性很明确， 衔接了 原型链（使 a 的原型的原型 === b 的原型 ）
- 适用于 创建一个  基于其他实例对象的  对象

##### 弊端：

- 原型式继承：**对象  作为 原型，避免不了  所有实例共享某个属性**
- 函数的复用性大大降低，因为返回结果是  一个实例对象，而非 构造函数

##### 补救方法

- ```js
  function object(Super){
      function Sub(){
          
      }
      Sub.prototype = new Super()
      return new Sub()
  }
  ```

- **因为每执行一次函数，就会根据某个实例对象   而只创建一个实例对象。如果两者是 一一对应，就可以解决实例共享属性的问题。**

- **解决： 每次都用一个新实例对象  去 赋值给 原型，这样 原型的数据 只为一个实例对象使用。**

- **总结：  这样的  补救  ，毫无意义！！！！！！！**

#### 5. 寄生式继承

- 寄生式继承，就是在 原型式继承的基础上 ，再为新实例对象添上所需的 属性。然后返回   新实例对象

####  6. 寄生组合式继承

- **寄生组合式继承**  是在  **组合式继承**  中改编而来的

- **组合式继承**， 首先 ` A.prototype = new B()` ,让 A 的原型获得所有  b 所有的属性 以及  原型指向；再而为了避免 **实例共享属性** ，在A构造函数中调用 B  `B.call( this )`   , 使 B 上的属性 再复制给 A ，覆盖属性（使得 属性不在  A 的原型上，而是 A 上）。

- **组合式继承   ，使用 实例 赋值原型的 方法，从而使  A 的原型  === B 的原型 + B构造函数内容 ；B的属性因为可能有引用类型的值，所以   A 构造函数中调用   `call()` 方法获得  B 中的属性和方法，                                      使得    A 构造函数内容  =  B构造函数内容 + A 另外添加的属性和方法。    **

  **这样  A 的实例 不会获得   A 原型上的B 的构造函数的内容，而是在  A 中的这些内容（属性就不会被共享）**

- **寄生组合式继承**

  - 从上述可以知道 ，仅仅是想 让   **B 的原型**  赋值给  **A 的原型**，想让  **B的内容**  复制一份 给 **A** 。

  - ```js
    function inheritPrototype(Sub,Sup){
        // 这里还有一个注意点
        // 就是不能直接 将 sup 的原型  赋值给  sub的原型
        //  因为 原型是对象，是引用类型 ，两者原型就会共享
        let proto = Object(sup.prototype)
        sub.prototype = proto
        sub.prototyep.constructor = sub
    }
    // 实现了 原型的拷贝
    
    function  A(){
        B.call(this)
        this.a = 'aaa'
    }
    inheritPrototype(A,B)
    ```

##### 优点：

- 避免了  属性的共享
- 减少了创建不必要的属性
- 只调用了一次  B( )





