# JS  正则表达式

## 1. 创建  正则

1. **正则表达式  字面量**

   - ```js
     var re = /ab+c/i
     ```

2. **`RegExp`  对象的构造函数**

   - 

     ```js
     var re = new RegExp("ab+c","i")
     ```

3. **匹配模式**

   - i   忽略大小写匹配
   - g   全局匹配（即  在整个 字符串中 找到，与正则相匹配的 所有字符串）
   - m  可以允许换行匹配
   
4. **正则表达式  字面量 与  构造函数  的区别**

   1. 注意：  字符串中有  `"\"` ，是要经过   `"\"`  转义字符 进行转义的。比如，你要打印带有  `"\"`  ，的字符串，就必须在 字符串中，这样写 :   `"\\"` 。 这样才能打印出  `"\"` 

   2. 在 正则表达式 中  `"\"`  ，在  非特殊字符之前的反斜杠表示下一个字符是 特殊字符，而在 特殊字符之前的反斜杠表示下一个字符不是特殊字符。

   3. 将字符串字面量的 正则表达式   转变为   RegExp 构造函数创建的 正则表达式，需要  字符串级别 和 正则表达式级别  都对他进行转义。如下：

      ```js
      /[a-zA-z]:\\/
      new RegExp("[a-zA-Z]:\\\\")
      // 四个斜杠
      // 因为字符串要对斜杠 进行转义，使其真正的展现出来，所以在  斜杠之前 使用了 斜杠
      ```

   4. **区别  2 ：**

      1. 正则字面量始终会共享 同一个  RegExp 实例

         ```js
         var re = null,
           i;
         for (i=0; i < 10; i++){
          re = /cat/g;
          re.test("catastrophe");
         }
         // 当进行了 第一次的循环，得到  "cat"
         // 第二次 调用时，是从 "catastrophe"  索引 为 3 开始的，一直都是同一个正则实例对字符串进行匹配
         //所以也就 保存了之前的属性，lastIndex( 开始下一个匹配的起始索引值 )
         ```

      2. 正则构造函数创建的  正则表达式，每次都会创建新的实例

         ```js
         for (i=0; i < 10; i++){
          re = new RegExp("cat", "g");
          re.test("catastrophe");
         }
         // 每次都创建了一个新的  RegExp 实例
         // 所以 每次得到的结果是 "cat"
         ```

5. **正则表达式 匹配返回结果 （是一个数组）**

   1. 数组的第一个值是  匹配到的字符串 
   2. 其他的值是所有被记住的子字符串
   3. **该数组还有其他两个属性**
      - `index` :  匹配到的字符串，是从源字符串中的那个索引开始匹配到的
      - `input`:   初始字符串

6. **`RegExp` 实例属性**

   - `lastIndex`   开始下一个匹配的索引值（只有 在使用  g （全局匹配）的情况下才会出现），因为只有 全局下 才会对一个字符串进行多次匹配，寻找出所有 符合 正则的 字符串。
   - `source`    模式字面文本（ 以字符串的形式 返回  正则表达式模式  ）

7. **反斜杠的特殊**

   - 正则要匹配 `"\"` 时，必须使用  `"\"`  对 `"\"` 进行转义。所以 正则字面量匹配  `"\"` 时，，如下：

     ```js
     /\\/g
     ```

   - 匹配 `"\"` 正则构造函数，构建如下：

     ```js
     new RegExp("\\\\","g")
     ```

     

## 2. 正则表达式  字符匹配

### 1. 模糊匹配

1.  横向模糊匹配  （是指  字符串的长度）
   - 使用 量词 实现， 字符串的长度。如：`{2,5}   *  +   ?`
2.  纵向模糊匹配    ( 是指  字符串中某些 字符的 不确定性 )
   - 如： `[234]     \d        \w           \s           .`

### 2. 字符组

1. 其 在 字符组中，只需要匹配到一个字符就行
   - `[abc]`  表示 匹配一个字符，它可以是  a  b  c 之间的任何一个。

#### 1. 范围表示法

1. `[1-9a-zA-Z]`  这类，用连字符来省略  和 简写。

#### 2. 排除字符组（ 反义字符组 ）

1. 可以是任何字符，但是就是不能是  a  b  c
2. `[^abc]`  表示 除了  a b  c 之外的 任何一个字符

#### 3.常见的简写形式

1. `\d`  	数字               digit
2. `\D`      非数字
3. `\w`      数字   字母  下划线           word
4. `\W`      非单词字符
5. `\s`       空白字符
6. `\S`       非空白字符
7. `.`         通配符，几乎任意字符
8. **匹配任何字符**
   - `[\d\D]     [\w\W]      [\s\S]    [^]   ` 最后一个非空有意思

### 3.量词

#### 1. 量词简写

1. `{m,}`   至少出现  m 次
2. `{m} `     出现  m  次
3. `?`         出现  0  或  1 次
4. `+`          至少 出现  1 次
5. `*`          至少 出现  0 次

#### 2. 贪婪匹配  和  惰性匹配

1. 使用量词时，量词后面没有加  问号 ，都是 贪婪匹配
   - `/\d{2,5}/`   会尽可能的去匹配 多个（且 大于 两个） 的字符
2. 使用  量词时，量词后面 有加 问号， 都是 惰性匹配
   - `/\d{2,5}/`    会尽可能的  少去匹配字符（但是 至少 两个）

### 4. 多选分支

- 多选分支  与    字符组差不多，但是 分支 可以是 字符串，也可以是  字符。都是 在其中匹配其一
- 多选分支  与  或运算 相似，即 如果匹配到了一个，就立马结束。**惰性匹配**
- `/google|chrome/g`    只会 匹配两个单词中的一个

### 5. 案例分析

1. 匹配   16进制颜色值，： `#FFF`   `#efefef`  `#Ffe	`   `#Fc01DF`
   - **字符  或者  数字，即 `[0-9a-fA-F]`**
   
   - **#后面  3个  或者 6个**
   
   - ` var regex = /#([0-9a-fA-F]{6}|[0-9a-fA-F]{3})/g; `
   
   - ```js
     要求匹配：
     
     F:\study\javascript\regex\regular expression.pdf
     F:\study\javascript\regex\
     F:\study\javascript
     F:\
     //  [^\\:*<>|"?\r\n/]   匹配非特殊字符
     /^[a-zA-Z]:\\([^\\:*<>|"?\r\n/]+\\)*([^\\:*<>|"?\r\n/]+)?$/
     ```
   
2. **匹配  id 的值**

   - ```html
       <div id="container" class="main"></div> 
     ```

   - ```js
     var regex = /id=".*"/
     // 这种方法 并不行
     //  因为量词都是贪婪的，匹配的结果可能是: "container" class="main"
     //  匹配到最后一个  双引号
     var regex = /id=".*?"/   // 使用非贪婪匹配
     
     
     // 最优解
     var  regex = /id="[^"]*"/
     // 匹配双引号中  没有双引号的 字符串
     
     ```

## 3. 正则表达式 位置匹配

- **字符匹配  是整个模式 取匹配出一个字符串， 这个字符串  长度可能是多少、 字符串的字母可能是什么**
  - 所以 **字符匹配就变成了：** 字符组  +  量词
- **位置匹配  是整个模式  匹配一个位置，这个位置 前面可能有什么  、后面有什么、和整个源字符串的结尾是什么关系、和整个源字符开始是什么关系**

### 1.什么是位置

- 单词之间的位置，包括  头部  和 尾部的位置

### 2.如何匹配位置

- **`^`				（匹配行的  开始）**

- **`$`                （匹配行的  结束）**

- **`\b`                 单词边界**   

  - 单词边界  就是一个单词的边界（单词是由  字母  数字 下划线 组成的）

  - ```js
    var result = "[JS] Lesson_01.mp4".replace(/\b/g, '#');
    console.log(result);
    // => "[#JS#] #Lesson_01#.#mp4#"
    // "JS"  是一个完整的单词
    // "Lesson_01"  
    // "mp4"
    ```

    

- **`\B`                 非单词边界**

  - 非单词边界  就是 非单词（非单词：不是 字母  数字  下划线）的边界，加上  单词中字母之间的位置

  - ```js
    var result = "[JS] Lesson_01.mp4".replace(/\B/g, '#');
    console.log(result);
    // => "#[J#S]# L#e#s#s#o#n#_#0#1.m#p#4"
    ```

    

- **`(?=p)`           先行断言（你先行  p 断言，针对前面的位置）**

  - ```js
    var result = "hello".replace(/(?=l)/g, '#');
    console.log(result);
    // => "he#l#lo"
    // 匹配一个位置，该位置的后面是字母 "l"
    
    ```

    

- **`(?!p)`           负先行断言**

  - ```js
    var result = "hello".replace(/(?!l)/g, '#');
    
    console.log(result);
    // => "#h#ell#o#"
    // 匹配一个位置，该位置的后面不是字母 "l"
    // 注意： 位置出来单词之间，还包括  头部 和 尾部的位置
    ```

- **`(?<=p)`         后行断言  （你后行 p 断言，针对后面的位置）**  

- **(?<!p)          负后行断言**

### 3.位置匹配案例

- **不匹配任何东西的正则**

  - `/.^/`   匹配一个字符，且该字符后面是 开头

- **数字千位分隔表示法**

  - "12345678"   >>  "12,345,678"

  - **思路：从结尾开始算，三个数字  六个数字.... 前面的位置  替换成 `,`   >>    ` /(?=(\d{3})+$)/g ` **

  - **导致：**  "123456789"   >>  ",123,456,789"

  - **思路1： 这个位置不能是  开始的位置    **

    ` reg = /(?!^)(?=(\d{3})+$)/g `**   也可以是  `reg = /(?<!^)(?=(\d{3})+$)/g`

- **验证码密码问题**

  - 密码 6 -12位，由数字  大小写字母组成，必须包含两种字符
  -  至少包含数字 `var reg = /(?=.*[0-9])^[0-9A-Za-z]{6,12}$/;`
  - `/(?=.*[0-9])^/`  **怎么理解**
    1. 匹配开始之前的一个位置，那还是指的是 开始的那个位置
    2. `(?=.*[0-9])`   开始之后字符串中  寻找一个子字符串（包含一个数字的  字符串，就证明了 包含有数字）
  - **第二种理解：（ 只能是 数字  大小写字母的前提下）不能全是 数字，不能全是 字母**
    - ` var reg = /(?!^[0-9]{6,12}$)(?!^[a-z]{6,12}$)(?!^[A-Z]{6,12}$)^[0-9A-Za-z]{6,12}$/; `









