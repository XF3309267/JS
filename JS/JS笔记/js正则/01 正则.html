<!DOCTYPE html>
<html lang="en">

<head>
    <title></title>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!-- <link href="css/style.css" rel="stylesheet"> -->

    <style>
        .box {
            width: 500px;
            height: 300px;
            margin: 20px auto;
            padding: 20px;
            border: 1px solid black;
        }
    </style>
</head>

<body>

    <div class="box">
        <input type="text" class="text">
        <input type="button" class="bt" value="提交">
    </div>

    <script>
        //  g   >>>     全局匹配
        //  i   >>>     区分大小写匹配
        //  m   >>>     多行匹配

        // 定义正则表达式的方法 ： 构造法 和  直接量
        // 1. 构造正则表达式
        //  使用 RegExp 构造函数 定义正则表达式对象     >>  new RegExp(pattern,attributes) 
        //  pattren 是一个字符串，指定正则表达式的模式 或者 其他正则表达式
        //  attributes  是一个可选的 修饰性标志，包含 "g" "i" "m" 或者 他们的组合 "gi"
        //  举例： 
        //      1. var r = new RegExp("a","gi");         var a = str.match(r);
        //      2. var r = new RegExp("\\b\\w","gi")
        //         解释： "\b" 表示单词的边界; "\w" 表示任意 Ascall字符;
        //                反斜杠表示转义序列，避免 Regular()构造函数误解，必须使用 "\\"表示 "\"
        //      3. 如果第一个参数是 正则表达式 则第二个参数可以省略

        //  构造正则表达式对象 
        var a = new RegExp("\\b\\w", "gi");
        //  对正则表达式对象进行 封装
        var b = new RegExp(a);
        //  Regexp()作为函数使用，参数是 正则表达式（a） ，
        //  那么它仅返回正则表达式，不再创建新的 RegExp 对象
        var c = RegExp(a);
        console.log("typeof a = " + typeof a);
        console.log("typeof b = " + typeof b);
        console.log("typeof c = " + typeof c);

        //  RegExp()构造函数接受字符串，而不是正则表达式的匹配模式，
        //  所以第一个参数中的 特殊字符 必须使用 双斜杆 来表示，
        //  第二个参数应该用双引号包含

        //  正则表达式直接量 按正则表达式的规则定义，普通字符
        //  和特殊字符都会被正确解释


        // 正则表达式直接量
        //  正则表达式直接量使用 双斜杆 作为分割符进行定义，双斜杆之间包含 正则表达式的模式，
        //  模式中不能有引号，标志字符(g  i m)放在最后一个斜杆的后面

        // 动态创建正则表达式，必须使用 RegExp构造函数

        // var a = [
        //     "I am a boy",
        //     "I am a student",
        // ];
        // var t = document.querySelector('input.text');
        // var w = document.querySelector('input.bt')


        // w.addEventListener('click', showResult);

        // function showResult() {
        //     var va = t.value;
        //     var r = new RegExp(va);
        //     for (const i in a) {
        //         if (a.hasOwnProperty(i)) {
        //             const element = a[i];
        //             console.log(element);
        //             var res = element.match(r);
        //             console.log("result = " + res);
        //         }
        //     }
        // }






        //  1. 返回最后一个子模式所匹配到的字符串（RegExp.lastParen 或者  RegExp["$+"](简写)）
        //  1. 若最后一个子模式没有匹配到字符串 则返回空字符串
        //  RegExp.input    &_  被执行匹配的字符串
        //  RegExp.index    当前模式匹配的开始位置，从 0 开始计数，初始值为 -1,每次匹配，每次改变
        //  RegExp.lastIndex  当前模式匹配的最后一个字符的下一个字符位置，初始值为 0 
        //                    每次匹配每次改变，可手动 将值改变为 0;当匹配不到是，返回0；
        //  RegExp.lastMatch  $&    匹配成功返回的字符串
        //  RegExp.lastParen  $+    最后子模式匹配的字符串
        //  子模式 >>>   即是 整个模式中的 一个 分支模式
        //      理解：可以是 括号 括起来，或者其他分隔（只要明显区分，即可分为多个子模式）
        //            整个模式，从第一个子模式开始匹配。第一个匹配成功，
        //            则从成功的下一个位置进行第二个子模式匹配，
        //            只有整个模式匹配成功，才算模式匹配成功
        //  RegExp.leftContext  $`  所匹配到的字符串左边的所有内容，初始值为空字符串，每次匹配每次改变 
        //  RegExp.rightContext $'  同上 右边的
        //  $1-$9   $1-$9   只读属性，$1-$9 分别是第一个到第九个子模式所匹配到的内容，
        
        //                  如果超过九个，就最后面的九个
        //                  在一个匹配模式中可以指定任意多个小括号包含的子模式，但 RegExp
        //                  静态属性只能存储最后九个
        var re = /Java(Script)/gi;
        var s = "JavaScript,not Javascript";
        console.log("00 RegExp.lastIndex  =" + re.lastIndex);
        var aa = re.exec(s);

        //   index 属性 ？？？？？？？？？？
        console.log("RegExp.index  =" + RegExp.index);

        console.log("RegExp.lastIndex  =" + re.lastIndex);
        console.log("lastMatch = " + RegExp.lastMatch);
        console.log("RegExp.lastParen = " + RegExp.lastParen);
        console.log('11 RegExp [$+] =' + RegExp["$+"]);
        var aa = re.exec(s);
        console.log("22 RegExp.index  =" + RegExp.index);
        console.log("22 RegExp.lastIndex  =" + re.lastIndex);
        var aa = re.exec(s);
        console.log("33 RegExp.lastIndex  =" + re.lastIndex);
        // console.log('22 RegExp [$+] =' + RegExp["$+"]);
        // **********************************************************

        //  2.重复类量词

        // 贪婪模式 和 惰性模式
        // ********************
        //       ？ {n} 和 {n,m} ,表现为贪婪的有限性
        //       *  +   和 {n,}  表现为贪婪的无限性
        //          
        //      重复类量词都具有 贪婪性，在条件允许的前提下，会尽可能匹配多个字符
        //      它的匹配过程是从整个字符串开始查看，如果不匹配就去掉最后一个，
        //      再看看是否匹配，如此循环一直到匹配或字符串空为止，
        //  

        //  例子： 
        vars = "abbbaabbbaaabbb1234";
        var re1 = /.*bbb/g; //*是贪婪量词
        re1.test(s);
        // 这个匹配过程将从整个字符串开始：（以下是匹配过程）
        re1.test("abbbaabbbaaabbb1234"); //false  ，则去掉最后一个字符4再继续
        re1.test("abbbaabbbaaabbb123"); //false , 则继续
        // 。。。。。。。
        re1.test("abbbaabbbaaabbb"); //true ，结束 

        // ******************
        //      与贪婪匹配相反，惰性匹配遵循另一种算法：尽可能匹配少的字符
        //      在贪婪量词的后面加多一个?就变成了惰性量词，它的匹配过程相反，
        //      是从前面第一个开始，不匹配则加一个，如此循环直到字符串结束
        re1.test("a"); //false,  再加一个
        re1.test("ab"); //false,  再加一个
        re1.test("abb"); //false,  再加一个
        re1.test("abbb"); //true,   匹配了，保存这个结果，再从下一个开始
        re1.test("a"); //false,  再加一个
        re1.test("aa"); //false,  再加一个
        re1.test("aab"); //false,  再加一个
        re1.test("aabb"); //false,  再加一个
        re1.test("aabbb"); //true,   匹配了，保存这个结果，再从下


        // 3.边界量词
        //  ^   >>>>>   匹配开头，在多行检测中，会匹配一行的开头
        //  $   >>>>>   匹配结尾，在多行检测中，会匹配一行的结尾
        var ss = "how are you";

        var rr = /(?:\w+)$/;
        var tt = /^(?:\w+)/;
        var rr1 = /(\w+)$/;
        var rr2 = /^(\w+)/;

        var aaa = ss.match(rr); //   结果为：you
        var aaat = ss.match(tt); //  结果为：how
        var aaa1 = ss.match(rr1);
        console.log("RegExp.$1 = " + RegExp.$1);
        var aaa2 = ss.match(rr2);
        console.log("RegExp.$1 = " + RegExp.$1);


        console.log("aa = " + aaa);
        console.log("aa1 = " + aaa1);


        // **********************************************

        // 声明量词： 正向声明 和 反向声明
        //      正向声明： 指定匹配模式后面的字符（A）必须匹配，但不返回 A 
        //                 正向声明使用 "(?=匹配条件)"表示
        //      反向声明： (?!=匹配条件)，所能匹配的字符后面不跟随 A
        //      例子： var s = "a:123 b=345";
        //             指定只有在 \w* 所能匹配的字符后面跟随一个  "=",才能够执行\w*匹配
        //             var r = /\w*(?==)/;
        //             (或则：var r = /w*(?!==)/)
        //             var a = s.match(r);  返回： b  (或则结果为： a)


        var str23 = "a ="
        var r23 = /\w*(?==)/;
        var a23 = str23.match(r23).toString();
        console.log("a23 = " + a23);
        console.log("typeof a23 = " + typeof(a23));


        var codeA23 = a23.charCodeAt();
        console.log("codeA23 = " + codeA23);

        // var codeA23 = String.fromCharCode()

        //  表达式分组
        //      使用小括号操作符可以对正则表达式字符串进行任意分组
        //      小括号内的字符串表示 子表达式，或者称为 子模式
        //      子模式具有独立的匹配功能，结果也具有独立性，量词跟在量词后面，也会作用于整个子表达式

        // 如果 regexp 没有标志 g,该数组的第 0 个元素存放的是匹配文本，
        // 而其余的元素存放的是与正则表达式的子表达式匹配的文本
        // 如果有标志g，它的数组元素中存放的是 stringObject 中所有的匹配子串
        // 而且也没有 index 属性或 input 属性。

        // 在同一个正则表达式的后部可以引用前面的子表达式，
        //  通过在字符 "\"后加一位或多位数字实现
        //  数字指定了带括号的子表达式的正则表达式的位置，
        //  位置的编号根据左括号的顺序来的
        // 对于正则表达式中前面子表达式的引用，所指的是与那个模式向匹配的文本
        // 例子：
        //      var s = "<h1>title<h1><p>text<p>"
        //      var r = /(<\/?\w+>).*\1/g;     >>>  "\1"引用 <h1> 和 <p>
        //      var r = /((<\/?\w+>).*\2)/g;   >>>  "\1"引用 <h1> 和 <p>
        //      因为 前面的子表达式只能匹配到  <h1> 和 <p>


        //  子表达式的引用
        //      正则表达式执行匹配算法时，表达式计算自动把每个分组（子表达式）
        //      匹配的文本临时存储起以备将来的使用。
        //      这些存储在分组中的特殊值，被称为    反向引用    。
        //      反向引用 将遵循从左到右的顺序，根据子表达式左括号的顺序。
        //          如：（RegExp.$1  或 $1）
        //          在此举一个 replace 例子
        //          var s = "aa11bb22c3d4";
        //          var r = /(\w+?)(d+)/g;
        //          var b = s.replace(r."$2$1");
        //          b = "11aa22bb3c4d"
        //      子表达式会占用一定的系统的资源,较长的正则表达式中,存储反向会降低匹配速度
        //          但很多时候分组仅是为了设置操作单元,而不是为了引用,这时候建议使用一种
        //          非引用型分组，它不会创建方向引用
        //          只需在左括号后加 ?:  如： var r = /(?:w*?)|(?:\d*?)/;

        var s24 = "javascript is not java";
        var r24 = /java(script)/g;
        var a24 = s24.match(r24);
        console.log("a24 = " + a24);
        console.log("a24.length = " + a24.length);
        console.log("RegExp.$1 = " + RegExp.$1);


        var s25 = "ab=21,bc=45,cd=43";
        var r25 = /\w+=(\d*)/g;
        var a25 = s25.match(r25);
        console.log("a25 = " + a25);
        console.log("a25.length = " + a25.length);



        // var str = "<><head><title><body>";
        // var r = /<.*?>/;
        // var r1 = /(<.*>)(<.*>)/;
        // var a = str.match(r);
        // var b = str.match(r1);
        // var c = r1.exec(str);
        // console.log("r1.lastMatch = " + r1.lastMatch);

        // console.log("b = " + b);
        // console.log("b.length = " + b.length);

        // // console.log("b[0] =" + b[0]);
        // console.log("b[1] =" + b[1]);
        // console.log("b[2] =" + b[2]);
        // console.log("a.length = " + a.length);
        // console.log("a = " + a);
        // console.log("a[0] = " + a[0]);
        // console.log("a[1] = " + a[1]);
        // for (const i in a) {
        //     if (a.hasOwnProperty(i)) {
        //         const element = a[i];
        //         console.log("element = " + element + "  lastIndex = " + r.lastIndex);
        //     }
        // }
    </script>
</body>

</head>